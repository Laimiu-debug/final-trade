# 趋势选股回测优化方案

## 问题

趋势选股应用做回测时，每天按策略跑一次全市场，导致回测极慢。

根因：**逐股票串行 + 每只股票内逐日 rolling 全量重算**，复杂度为 `O(股票数 × 交易日数 × 信号计算)`，三层嵌套循环。

---

## 策略背景

两套并行选股系统：

1. **趋势票 v1.0**（[Phase 1 — 数据层](https://www.notion.so/Phase-1-f7bb26ac0c934a25bc46582c90d1d950?pvs=21)）：40 日涨幅排名前 500 → 图形/均线排列 → 量能健康度 → 题材确认，五层漏斗
2. **威科夫量价 v2.0**（[威科夫量价选股系统 v2.0 —— 信号 + 策略 + 代码](https://www.notion.so/v2-0-22e76e8bb1404ad291d58de1cc76be40?pvs=21)）：9 个量化信号（S1-S9）→ 阶段判断（吸筹/上涨/派发）→ 买卖动作生成

---

## 方案一：矩阵化（核心，必须先做）

### 思路

将 OHLCV 数据从长表 pivot 成 `(日期 × 股票)` 的二维矩阵，所有 rolling / rank / 信号判断 **一次覆盖全市场全历史**，消除一切 `for` 循环。

### 信号矩阵化示例

```python
# OHLCV pivot 成 (T, N) 矩阵
close  = df.pivot(index='date', columns='code', values='close')
volume = df.pivot(index='date', columns='code', values='volume')
high   = df.pivot(index='date', columns='code', values='high')
low    = df.pivot(index='date', columns='code', values='low')

# S1: ATR 收窄 — 全市场一次性
atr_short = high.rolling(20).max() - low.rolling(20).min()
atr_long  = high.rolling(60).max() - low.rolling(60).min()
S1 = (atr_short / atr_long) < 0.7  # (T, N) 布尔矩阵
```

### 排名也是矩阵操作

```python
ret_40d = close.pct_change(40)
rank = ret_40d.rank(axis=1, ascending=False)
top500 = rank <= 500  # 每天的 Top 500，一行代码
```

### 回测零循环

```python
buy_signal  = top500 & S5 | S6
sell_signal = S8 | S9
position = buy_signal.shift(1).astype(int)
position[sell_signal.shift(1)] = 0
portfolio_ret = (close.pct_change() * position).mean(axis=1)
```

### 预期效果

单次回测从 **分钟级 → 秒级**。

---

## 方案二：并行（用于参数搜索）

### 适用场景

信号层矩阵化后单次已经很快，**并行应该用在多参数组合搜索上**，而不是信号计算上。

原因：矩阵 rolling 是 C 级连续内存遍历，单核已打满内存带宽，多进程反而引入数据拷贝开销。

### Python 方案

```python
from multiprocessing import Pool
from itertools import product

param_grid = list(product(
    [0.5, 0.6, 0.7, 0.8],      # ATR 阈值
    [0.4, 0.5, 0.6, 0.7],      # 缩量阈值
    [1.0, 1.2, 1.4],           # 供需比阈值
    [1.2, 1.5, 2.0],           # 突破量能倍数
    [0.08, 0.10, 0.12, 0.15],  # 止损比例
))  # 576 种组合

with Pool(processes=8) as pool:
    results = pool.map(run_one_backtest, param_grid)
```

### Rust 极致方案

```rust
use rayon::prelude::*;
param_grid.par_iter()
    .map(|params| run_backtest(ohlcv, params))
    .collect::<Vec<_>>();
```

无 GIL、零拷贝共享 OHLCV、SIMD rolling，576 组参数约 **2-5 秒**。

---

## 方案三：三层缓存架构（参数频繁调整）

参数变了不需要从头重算，将计算拆分为三层：

```
┌──────────────────────────────────┐
│  L0: OHLCV 原始矩阵              │  ← 加载一次，永不重算
├──────────────────────────────────┤
│  L1: rolling 中间量缓存           │  ← 窗口变了才重算（秒级）
│  MA、均量、ATR ratio、供需比等    │
├──────────────────────────────────┤
│  L2: 阈值判断 + 排名 + 回测       │  ← 参数变了重算（毫秒级）
└──────────────────────────────────┘
```

### 实现

```python
# L1: 预算所有常用窗口的中间量（只算一次）
cache = {}
for w in [5, 10, 20, 60]:
    cache[f'ma{w}']       = close.rolling(w).mean()
    cache[f'vol_ma{w}']   = volume.rolling(w).mean()
    cache[f'high_max{w}'] = high.rolling(w).max()
    cache[f'low_min{w}']  = low.rolling(w).min()

# L2: 参数变了，只做阈值比较（~50ms）
def apply_params(cache, params):
    S1 = cache['atr_ratio'] < params['atr_th']
    S2 = cache['vol_ratio'] < params['vol_th']
    # ... 纯广播比较，无 rolling
```

**效果**：Streamlit 上拖滑块改参数，结果实时刷新。

---

## 落地优先级

| 步骤 | 动作 | 预期收益 |
| --- | --- | --- |
| **①** | OHLCV pivot 矩阵化 + 信号矩阵化 | 单次回测分钟级 → 秒级 |
| **②** | 三层缓存（L0/L1/L2 拆分） | 参数调整毫秒级响应 |
| **③** | `multiprocessing` 参数网格搜索 | 576 组参数 ~1.5 分钟 |
| **④** | Rust 热路径 + PyO3（可选） | 蒙特卡洛/Walk-Forward 极致性能 |

---

## 注意事项

- S4（Spring）和 S6（Back Up）依赖前序信号状态，矩阵化时用 `rolling(5).max()` 传播
- S6 的 `ffill()` 在矩阵模式下注意 axis 方向是沿时间轴（axis=0）
- `calc_batch_indicators` 中的 `groupby('code')` 循环同样需要改为矩阵版
- 不要在矩阵化没做的情况下直接跳到并行 — 否则是"并行跑慢代码"